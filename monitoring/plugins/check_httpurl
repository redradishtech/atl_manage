#!/bin/bash
# check_http wrapper that parses the first argument as a full URL, breaking it into check_http flags (--ssl --sni -H .. -p .. -u ..). Args after the first are passed on to check_http

# https://stackoverflow.com/a/63993578/7538322
readonly URI_REGEX='^(([^:/?#]+):)?(//((([^:/?#]+)@)?([^:/?#]+)(:([0-9]+))?))?((/|$)([^?#]*))(\?([^#]*))?(#(.*))?$'
#                    ↑↑            ↑  ↑↑↑            ↑         ↑ ↑            ↑↑    ↑        ↑  ↑        ↑ ↑
#                    ||            |  |||            |         | |            ||    |        |  |        | |
#                    |2 scheme     |  ||6 userinfo   7 host    | 9 port       ||    12 rpath |  14 query | 16 fragment
#                    1 scheme:     |  |5 userinfo@             8 :...         ||             13 ?...     15 #...
#                                  |  4 authority                             |11 / or end-of-string
#                                  3  //...                                   10 path

url="$1"; shift
if [[ "$url" =~ $URI_REGEX ]]; then
    scheme=${BASH_REMATCH[2]}
    userinfo=${BASH_REMATCH[5]}
    host=${BASH_REMATCH[7]}
    port=${BASH_REMATCH[9]}
    path=${BASH_REMATCH[10]}
    query=${BASH_REMATCH[13]}
    #fragment=${BASH_REMATCH[15]}
    #echo "scheme: $scheme"
    #echo "userinfo: $userinfo"
    #echo "host: $host"
    #echo "port: $port"
    #echo "path= $path"
    #echo "query= $query"
    #echo "fragment= $fragment"
else
    echo >&2 "URL did not match pattern: $url"
	exit 1
fi

cmd=(check_http)
cmd+=(-H "$host")
if [[ "$scheme" = https ]]; then
	cmd+=(--ssl --sni)
	if [[ ${port:-443} != 443 ]]; then
		cmd+=(-p "$port")
	fi
else
	if [[ ${port:-80} != 80 ]]; then
		cmd+=(-p "$port")
	fi
fi
if [[ -n $path ]]; then
	fullpath="$path"
	if [[ -n $query ]]; then
		fullpath+="?$query"
	fi
	#ignore fragment
	cmd+=(-u "$fullpath")
fi

#echo "${cmd[@]}" "$@"
set -x
exec "${cmd[@]}" "$@"
